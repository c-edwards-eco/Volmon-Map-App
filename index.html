<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <title>Volmon Map App</title>
  <!-- Bootstrap CSS first -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
    integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous" />
  <!-- Then Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
    integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
  <!-- Finally, our styles -->
  <style>
    body {
      background: #0d2d6c;
      font-family: "Open Sans", sans-serif;
      font-weight: 400;
      font-size: 100%;
      overflow-x: hidden;
      /* need to figure out what was making a lil scrolling to the right possible */
    }

    h1 {
      font-weight: 500;
      font-size: 250%;
    }

    p {
      line-height: 1.7rem;
    }

    a {
      color: #fdb515;
    }

    a:hover {
      color: #ffed46;
      text-decoration: none;
    }

    a:hover {
      color: rgb(130, 131, 132);
      text-decoration: none;
    }

    header {
      /* need to check in with boyd about aligning these elements in a less stupid way */
      display: flex;
      color: #fff;
      width: 100%;
      justify-content: space-between;
      align-items: flex-end;
      background-color: #0d2d6c;
      padding-left: 10px;
      padding-top: 11px;
    }

    footer {
      position: fixed;
      bottom: 0;
      width: 100%;
      padding-top: 5px;
      height: 2.5rem;
      background-color: #0d2d6c;
      color: #fff;
      display: flex;
      justify-content: center;
    }

    .btn-custom {
      /* i want button right aligned, centered with respect to the vertical axis */
      background-color: #00aae7;
      color: white;
      border: 0.5px solid white;
      margin-right: 15px;
      margin-bottom: 23px;
    }

    .btn-custom:hover {
      background-color: #68cef2;
      color: white;
      border: 0.5px solid white;
    }

    .offcanvas-body {
      background-color: #0d2d6c !important;
    }

    .offcanvas-header {
      background-color: #0d2d6c !important;
    }

    .leaflet-bar a {
      /* Override the default style for Leaflet's zoom  */
      background: #0d2d6c;
      color: #fff;
    }

    .tab-container {
      /* i want my tabs to be flush with bottom of header, padded right from map info button */
      margin-bottom: 0;
      padding: 0;
    }

    .tab {
      /* tabs will control layer visibility, illusion of being separate maps */
      background-color: #fff;
      color: #0d2d6c;
      border: 2px solid #0d2d6c;
      padding: 0.5rem 1rem;
      cursor: pointer;
      font-size: 1rem;
      margin-right: 5px;
      transition: background-color 0.3s;
    }

    .tab:hover {
      background-color: #fdb515;
    }

    .tab.active {
      border: 2px solid #fff;
      /* illusion of it being flush with the map like file tabs when active */
    }

    #map {
      /* height is set in JS */
      background: #494848;
      z-index: 0;
      /*keeps it behind headers/footers*/
    }

    .legend {
      font-size: 1rem;
      border-radius: 5px;
      max-width: 200px;
      font-family: "Open Sans", sans-serif;
      background: rgba(100, 100, 100, 0.9);
      color: rgba(244, 244, 244, 0.8);
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
    }

    .legend h3 {
      font-size: 1.1em;
      font-weight: normal;
      color: #ddd;
      margin: 0 0 10px 0;
    }

    .legend span {
      width: 20px;
      height: 20px;
      margin: 0 10px 4px 0;
    }

    .legend label {
      font-size: 0.9rem;
    }

    /* Small devices (landscape phones, 576px and up) */
    @media (min-width: 576px) {}

    /* Medium devices (tablets, 768px and up) */
    @media (min-width: 768px) {}

    /* Large devices (desktops, 992px and up) */
    @media (min-width: 992px) {}

    /* Extra large devices (large desktops, 1200px and up) */
    @media (min-width: 1200px) {}
  </style>
</head>

<body>
  <header>
    <h1>
      <img src="graphics/DEEP_Primary_Seal_Reverse_150px.png" width="70px" />
      Volunteer Monitoring Mapping Application
    </h1>

    <div class="tab-container">
      <button id="RBV" class="tab">Riffle Bioassessment by Volunteers</button>
      <button id="VSTeM" class="tab">
        Volunteer Stream Temperature Monitoring
      </button>
      <button id="CTLW" class="tab">CT Lake Watch</button>
    </div>

    <div class="header-info">
      <a class="btn btn-custom" data-bs-toggle="offcanvas" href="#offcanvasExample" role="button"
        aria-controls="offcanvasExample">
        Map Info
      </a>
    </div>
  </header>

  <!-- full-width row with 0 padding -->
  <section class="row">
    <div class="p-0">
      <!-- Map container with height dynamically calc'd in JS. -->
      <div id="map"></div>
    </div>
  </section>

  <!-- Full-width row with similar style as header. -->
  <footer>
    <!-- Content dynamically generated in JS. -->
    <p class="text-center"></p>
  </footer>

  <!-- Off-canvas element outside of container
appears from horizontal start (left) of viewport. -->
  <div class="offcanvas offcanvas-start bg-dark text-white" tabindex="-1" id="offcanvasExample"
    aria-labelledby="offcanvasExampleLabel">
    <div class="offcanvas-header">
      <h5 class="offcanvas-title" id="offcanvasExampleLabel">Map Info</h5>
      <!-- Button to close off-canvas element. -->
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
    <div class="offcanvas-body">
      <h3 class="py-2">Volunteer Water Monitoring in Connecticut</h3>
      <p>
        Connecticut is fortunate to be a water-rich state. We have thousands
        of miles of rivers and streams, hundreds of lakes and ponds, and of
        course, the magnificent Long Island Sound.
        <br /><br />
        CT DEEP encourages groups and individuals interested in helping to
        conserve and protect our water resources to become volunteer water
        monitors, also commonly referred to as 'citizen scientists' and
        'community scientists.'
        <br /><br />
        The CT DEEP coordinates a statewide Volunteer Water Monitoring Program
        that trains volunteers to collect water quality data using a variety
        of DEEP certified methods. To learn more, or to view monitoring
        results, click on the corresponding program tab.
      </p>
      <hr />
      <h3 class="py-2">Questions?</h3>
      <ul class="list-unstyled">
        <li>
          Contact the
          <a href="#">DEEP Volunteer Water Monitoring Program Coordinator </a>
        </li>
        <li>Data retrieved from the <a href="#">Water Quality Portal</a></li>
      </ul>
    </div>
  </div>

  <!-- Bootstrap JS first-->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous">
  </script>
  <!-- Then Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
    integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
  <script>
    // Add footer date
    setDate();

    // set global variables for header, map container, and footer
    const header = document.querySelector("header");
    const mapContainer = document.querySelector("#map");
    const footer = document.querySelector("footer");

    // set map height to fill window
    mapContainer.style.height =
      window.innerHeight - header.offsetHeight - footer.offsetHeight + "px";

    // initial Leaflet map options
    const options = {
      center: [41.53, -72.6736],
      zoom: 9.5,
      zoomSnap: 0.1,
      zoomControl: false,
      attributionControl: false,
    };

    // create Leaflet map and apply options
    const map = L.map("map", options);

    // request a basemap tile layer and add to the map
    var Esri_WorldGrayCanvas = L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}", {
        attribution: "Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ",
        maxZoom: 16,
      }
    );
    Esri_WorldGrayCanvas.addTo(map); // stadia required an api key and i dont wanna deal with that right now

    // add zoom control
    map.addControl(
      L.control.zoom({
        position: "topright",
      })
    );


    // fetch data.. data points from WQP, polys from internal data, river lines from integrated report
    // boundary first as it never changes
    fetch("data/ct_boundary.geojson") // also need to make this draw on top of the other layers
      .then(function (response) {
        return response.json();
      })
      .then(function (data) {

        setActiveTab("RBV"); // active by default
        drawBoundary(data); // function for each type of data
        // return a new fetch call and continue the chain
        return fetch("data/assessed_river.geojson");
      })
      .then(function (response) {
        return response.json();
      })
      .then(function (data) {
        streams = drawStreams(data); // initial styling
        blueStreams = drawBlueStreams(data);
        streams.addTo(map);
        // return a new fetch call and continue the chain
        return fetch("data/rbv_watersheds.geojson");
      })
      .then(function (response) {
        return response.json();
      })
      .then(function (data) {
        RBVWS = drawRBVWS(data);
        RBVWS.addTo(map); // display by default
        // return a new fetch call and continue the chain
        return fetch("data/RBVmetrics.geojson");
      })
      .then(function (response) {
        return response.json();
      })
      .then(function (data) {
        RBVsites = drawRBV(data);
        RBVsites.addTo(map); // display by default
        // return a new fetch call and continue the chain
        return fetch("data/coldwatersites_us_drainage.geojson");
      })
      .then(function (response) {
        return response.json();
      })
      .then(function (data) {
        CWWS = drawCWWS(data);
        // return a new fetch call and continue the chain
        return fetch("data/VSTeMclasses.geojson");
      })
      .then(function (response) {
        return response.json();
      })
      .then(function (data) {
        VSTeMsites = drawVSTeM(data);
        // return a new fetch call and continue the chain

        return fetch("data/CTLWsites.geojson");
      })
      .then(function (response) {
        return response.json();
      })
      .then(function (data) {
        CTLWsites = drawCTLW(data);
      });

    // i am going to create functions for drawing each "type" of data, then figure out how to link interactivity to the tabs

    // boundary data - this never changes
    function drawBoundary(data) {
      const ctBoundary = L.geoJson(data, {
        style: function (feature) {
          return {
            color: "#000",
            weight: 2,
            fillOpacity: 0,
          };
        },
      }).addTo(map);
    }

    // rbv sites with color coding
    function drawRBV(data) {
      const RBVsites = L.geoJson(data, {
        // i think i will group the data  by the const and tie it to the tabs?
        pointToLayer: function (feature, latlng) {
          // either 4+ site or <4 site
          const maxScore = feature.properties.MaxScore;
          let color;
          if (maxScore >= 4) {
            color = "#FDB515";
          } else {
            color = "#0D2D6C";
          }

          return L.circleMarker(latlng, {
            // i may make this a nicer symbol? but this looks not bad to start
            radius: 6,
            fillColor: color,
            color: color,
            weight: 2,
            opacity: 1,
            fillOpacity: 0.8,
          });
        },
        onEachFeature: function (feature, layer) {
          // tooltip params
          const siteName = feature.properties.MonitoringLocationName;
          const siteID = feature.properties.MonitoringLocationIdentifier;
          const maxScore = feature.properties.MaxScore;
          const maxScoreYear = feature.properties.MaxScoreYear;
          const recentScore = feature.properties.RecentScore;
          const recentScoreYear = feature.properties.RecentYear;

          // info for decision-making (site selection)
          layer.bindTooltip(`<b>${siteName}:</b> ${siteID} <br>
          <b>Max result:</b> ${maxScore} MW in ${maxScoreYear}<br>
          <b>Most recent result:</b> ${recentScore} MW in ${recentScoreYear}`, {});
        },
      });
      return RBVsites; // return the RBVsites layer
    }

    //rbv high prio watersheds
    function drawRBVWS(data) {
      const RBVWS = L.geoJson(data, {
        style: function (feature, latlng) {
          return (
            latlng, {
              fillColor: "#9ECF7C",
              color: "#9ECF7C",
              weight: 0,
              opacity: 0,
              fillOpacity: 0.8,
            }
          );
        },
      });
      return RBVWS; // return the RBVWS layer
    }

    function drawStreams(data) {
      const streams = L.geoJson(data, {
        style: function (feature) {
          let color;
          // style based on active tab and layer info (informational vs decision making)
          const assessment = feature.properties.CT2022_A_1; // ALUS assessment determination
          if (assessment === "Fully Supporting") {
            color = "#00AAE7"; // light blue for full support
          } else if (assessment === "Not Supporting") {
            color = "#FF0000"; // red for not supporting
          } else {
            color = "#595959"; // grey for non-assessed lines
          }
          return {
            color: color,
            weight: 2,
            opacity: 1,
          };
        },
        onEachFeature: function (feature, layer) {
          // tooltip params
          const segmentName = feature.properties.ASSESSME_1;
          const assessment = feature.properties.CT2022_A_1;

          // info for decision-making (site selection)
          layer.bindTooltip(`<b>${segmentName}:</b> <br>
           ${assessment} ALUS`, {});
        },
      });
      return streams;
    }

    function drawBlueStreams(data) {
      const blueStreams = L.geoJson(data, {
        style: function (feature) {
          return {
            color: '#0D2D6c',
            weight: 2,
            opacity: 1,
          };
        },
        onEachFeature: function (feature, layer) {
          // tooltip params
          const segmentName = feature.properties.ASSESSME_1;

          // info for decision-making (site selection)
          layer.bindTooltip(`<b>${segmentName}</b>`, {});
        },
      });
      return blueStreams;
    }

    // VSTeM sites with color coding
    function drawVSTeM(data) {
      const VSTeMsites = L.geoJson(data, {
        pointToLayer: function (feature, latlng) {
          // either cold or not cold site (for now)
          const minScore = feature.properties.MinClassScore;
          let color;
          if (minScore == 1) {
            // my coldwater site classification
            color = "#00AAE7";
          } else {
            color = "#FFED46";
          }

          return L.circleMarker(latlng, {
            // temp symbology to differentiate from rbv sites
            radius: 6,
            fillColor: color,
            color: color,
            weight: 2,
            opacity: 1,
            fillOpacity: 0.8,
          });
        },
      });
      return VSTeMsites;
    }

    //coldwater hab watersheds
    function drawCWWS(data) {
      const CWWS = L.geoJson(data, {
        style: function (feature, latlng) {
          return (
            latlng, {
              fillColor: "#68CEF2",
              color: "#68CEF2",
              weight: 0,
              opacity: 0,
              fillOpacity: 0.8,
            }
          );
        },
      });
      return CWWS; // return the CWWS layer
    }

    // CTLW sites with static colors
    function drawCTLW(data) {
      const CTLWsites = L.geoJson(data, {
        pointToLayer: function (feature, latlng) {
          return L.circleMarker(latlng, {
            // temp symbology to differentiate from rbv sites
            radius: 6,
            fillColor: "#23AE49",
            color: "#23AE49",
            weight: 2,
            opacity: 1,
            fillOpacity: 0.8,
          });
        },
      });
      return CTLWsites;
    }

    // tab magic

    // tab functionality: RBV.. can i make this more efficient and do all at once?
    document.querySelector("#RBV").addEventListener("click", function () {
      RBVWS.addTo(map);
      streams.addTo(map);
      RBVsites.addTo(map);

      if (VSTeMsites) {
        map.removeLayer(VSTeMsites);
      }
      if (CWWS) {
        map.removeLayer(CWWS);
      }
      if (CTLWsites) {
        map.removeLayer(CTLWsites);
      }

      setActiveTab("RBV");
      // also need to make this work for each map legend
    });

    // tab functionality: VSTeM
    document.querySelector("#VSTeM").addEventListener("click", function () {
      CWWS.addTo(map);
      blueStreams.addTo(map);
      VSTeMsites.addTo(map);

      if (RBVsites) {
        map.removeLayer(RBVsites);
      }
      if (RBVWS) {
        map.removeLayer(RBVWS);
      }
      if (streams) {
        map.removeLayer(streams);
      }
      if (CTLWsites) {
        map.removeLayer(CTLWsites);
      }

      setActiveTab("VSTeM");
    });

    // tab functionality: CTLW
    document.querySelector("#CTLW").addEventListener("click", function () {
      CTLWsites.addTo(map); //

      if (RBVsites) {
        map.removeLayer(RBVsites);
      }
      if (RBVWS) {
        map.removeLayer(RBVWS);
      }
      if (streams) {
        map.removeLayer(streams);
      }
      if (VSTeMsites) {
        map.removeLayer(VSTeMsites);
      }
      if (CWWS) {
        map.removeLayer(CWWS);
      }
      setActiveTab("CTLW");
    });

    function setActiveTab(tabID) {
      // grab all tabs
      const tabs = document.querySelectorAll(".tab");
      // remove active class so only selected tab is active
      tabs.forEach((tab) => {
        tab.classList.remove("active");
      });
      // add active class
      const activeTab = document.querySelector(`#${tabID}`);
      if (activeTab) {
        activeTab.classList.add("active");
      }
    }

    // footer content
    function setDate() {
      const date = new Date();
      const year = date.getFullYear();
      const month = date.toLocaleString("default", {
        month: "long",
      });
      const footerText = document.querySelector("footer p");
      footerText.innerHTML = `${month}, ${year} | CT DEEP Water Monitoring`;
    }
  </script>
</body>

</html>